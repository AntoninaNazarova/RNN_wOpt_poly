/* 05.05.2020*/
//RNN 1 layer
//ATransformedBP
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <conio.h>
#include <string.h>
#include <fcntl.h>
#include <process.h>
#include <sys/stat.h>
#include <io.h>

int main()
{
static long ip,p;
static double r2,r1,r,r3,r4,r5,r6,r7,alf,eps,del1[3000],del2[3000],del3[3000],er[3000],tt[20],ttt[20];
static int nl,res,i2,i1,i_count1,ii,ii1,j1,jj,ij,jjj,i10,j2;
static char unsigned b[500];
static double sum,sum3,sum1,a[3000];
static int ipp,i,j,l,i3,i4,l4,i_sm[2000],ill,ippp,imin,i_count2;
static double s1[3000],s2[3000],s3[3000];
static double x[3000],x1[3000],x2[3000],x3[3000],x11[3000],ap,min,min3,amin,x4[3000];
static int jsum,nl1,max, nb, i_representation;
static int k,k1,i_max, i_volume,i_string,i_activation;
static char  smiles[2000];
static char  buf1[8000000];


double (*w1)[3000];
double (*w1p)[3000];
double (*w1j)[3000];
double (*w3)[3000];
double (*s_smile)[3000];
   w1=new double[3000][3000];
   w1p=new double[3000][3000];
   w1j=new double[3000][3000];
   w3=new double[3000][3000];
   s_smile=new double[3000][3000];
static char  buf[8000000],c[20];

static float stat[8000],stat3[8000],d[1000],sigma,sigma3,ak;
static float s_eps[3000],s_a[8000],s_z[8000];
static int i_count,i_count11,i_count33,i_count3,l_e,i_r,n,i5,i6,l1,l2,l3;


     FILE *stream;
     FILE *stream_Z;
     FILE *stream1;
     FILE *stream2;
     FILE *stream3;
printf("The name of the SMILES file in .dat format \n");
scanf("%s",smiles);
   if ((stream = fopen(&smiles[0], "rb")) == NULL)
   {
      fprintf(stderr, "Cannot open input file.\n");
      return 1;
   }

printf("Introduce type of an activation function, 1-Tanh | 2-Sigmoid |3-RELU \n");
scanf("%d",&i_activation);
printf("activation %d",i_activation);

   /* open a file for update */
   stream_Z = fopen("eps.dat", "r");

   /* open a file */
   stream1 = fopen("dbp1_d_SIGMOID_BP_Normalized.dat", "w"); /* RMSE vs epoch for test pool*/
   stream2 = fopen("dbp2_d_SIGMOID_BP_Normalized.dat", "w"); /* RMSE vs epoch for training pool*/
	stream3 = fopen("dbp3_d_SIGMOID_BP_Normalized.dat", "w"); /* Predicted eps*/

//__1. Initialization of the working registers___
   i_count2=0;
   amin=10000.;
   imin=0;
   min=1000.;
   min3=1000.;
	alf=0.0025*0.1;
//___Scaling factor___
   ap=160.0;
//___For reading eps data___
   c[0]=48;
   c[1]=49;
   c[2]=50;
   c[3]=51;
   c[4]=52;
   c[5]=53;
   c[6]=54;
   c[7]=55;
   c[8]=56;
   c[9]=57;

   tt[0]=1.;
   tt[1]=10.;
   tt[2]=100.;
   tt[3]=1000.;
   tt[4]=10000.;

   ttt[0]=0.1;
   ttt[1]=0.01;
   ttt[2]=0.001;
   ttt[3]=0.0001;
   ttt[4]=0.00001;
   ttt[5]=0.000001;
   ttt[6]=0.0000001;
   ttt[7]=0.00000001;
   ttt[8]=0.000000001;
   ttt[9]=0.0000000001;
   ttt[10]=0.00000000001;
   ttt[11]=0.000000000001;
   ttt[12]=0.0000000000001;
   ttt[13]=0.00000000000001;
   ttt[14]=0.000000000000001;
   ttt[15]=0.0000000000000001;
   ttt[16]=0.00000000000000001;
   ttt[17]=0.000000000000000001;
   ttt[18]=0.0000000000000000001;

//****** 2. DATA INIZIALIZATION *********
ii=0;
i_max=0;
//2.1___SMILES decoding (ASCII to binary)_____
//2.1.1____ Reading of SMILE array_____
nb=400000;
fread(buf,nb,1,stream);		//SMILE in BUF

//_____VOLUME ESTIMATION _____
i_volume=0;
i_string=0;
count:
	if(buf[i_volume]==10){i_string=i_string+1;}	//"10"&"0" END OF STRING
	if((buf[i_volume]==10)&(buf[i_volume+1]==0)){goto count1;}	//"10"&"0" END OF FILE
	i_volume=i_volume+1;
	goto count;
count1:
printf("\n Volume= %4d",i_volume); 	//VOLUME in i_volume
printf("\n NUMBER of STRINGS= %4d",i_string); 	//VOLUME in i_volume
//_____END VOLUME ESTIMATION _____


//2.1.2_________ MAX SMILE LENGTH CALCULATION _______
   i1=0;
cont3s:
	i_count=0.;
cont1s:
   if(buf[i1]==10) {goto cont2s;}	//"10" END OF STRING
   i1=i1+1;
   i_count=i_count+1;
   goto cont1s;
cont2s:
if(i_max<i_count) {i_max=i_count;}
//printf("\n %d i_max=  %d",i1,i_max);
//getch();
if(i1==i_volume){goto cont4s;}
   i1=i1+1;
	goto cont3s;
cont4s:
printf("\n i_max=  %d",i_max);	//MAX 0f STRING SMILE in i_max
getch();
//_________ END OF MAX SMILE CALCULATION _______
//2.1.3_____________ SMILE BINARY REPRESENTATION  _______
	ii=0;
   i1=0;
cont3:
	i_count=0.;
cont1:
   if(buf[i1]==10) {goto cont2;}
   i1=i1+1;
   i_count=i_count+1; 	// i_count - the LENGTH (in ASCCI symbols) of string SMILE
   goto cont1;

cont2:
//____*************** CONDITION ************______
//ii=0;
	for(i3=0;i3<i_count;i3++)
   {
   k=buf[i1-i_count+i3];
   	k1=k-128;
      if(k1>=0) {buf1[ii]=1;k=k1;} else{buf1[ii]=-1;}ii=ii+1;
	   	k1=k-64;
   	   if(k1>=0) {buf1[ii]=1;k=k1;} else{buf1[ii]=-1;}ii=ii+1;
	   		k1=k-32;
	   	   if(k1>=0) {buf1[ii]=1;k=k1;} else{buf1[ii]=-1;}ii=ii+1;
		   		k1=k-16;
		   	   if(k1>=0) {buf1[ii]=1;k=k1;} else{buf1[ii]=-1;}ii=ii+1;
			   		k1=k-8;
			   	   if(k1>=0) {buf1[ii]=1;k=k1;} else{buf1[ii]=-1;}ii=ii+1;
				   		k1=k-4;
				   	   if(k1>=0) {buf1[ii]=1;k=k1;} else{buf1[ii]=-1;}ii=ii+1;
					   		k1=k-2;
					   	   if(k1>=0) {buf1[ii]=1;k=k1;} else{buf1[ii]=-1;}ii=ii+1;
						   		k1=k-1;
						   	   if(k1>=0) {buf1[ii]=1;k=k1;} else{buf1[ii]=-1;}ii=ii+1;

	}//i3


	for(i3=i_count;i3<i_max;i3++)
   {
   buf1[ii] = 0; ii = ii+1;
   buf1[ii] = 0; ii = ii+1;
   buf1[ii] = 0; ii = ii+1;
   buf1[ii] = 0; ii = ii+1;
   buf1[ii] = 0; ii = ii+1;
   buf1[ii] = 0; ii = ii+1;
   buf1[ii] = 0; ii = ii+1;
   buf1[ii] = 0; ii = ii+1;
	}//i3


if(i1==i_volume){goto cont4;} //CONDITION "END OF FILE"

   i1=i1+1;
goto cont3;
//_____________END SMILE BINARY REPRESENTATION  _______


cont4:
printf("\n The start of the processing");

for(i=0;i<i_string;i++)
{
	for(i1=0;i1<i_max*8;i1++)
	{
   s_smile[i][i1]=(double)buf1[i*i_max*8+i1];
   }//i1
}//i

//2.2________________ARRAY FOR EPS __________________
nb=8000000;
fread(buf,nb,1,stream_Z);

//2.2.1_______ Decoding of array of eps______

i2=0;
i1=0;
mn2:
i_count1=0;
mn:
ii=buf[i1];if(ii==46) {j1=i_count1;}
ii=buf[i1];if(ii==10) {i1=i1+1;i_count1=i_count1+1;goto mn1;}

i1=i1+1;
i_count1=i_count1+1;
goto mn;

mn1:
//1.				//SAMPLE
i3=buf[i1-i_count1+j1];
//printf("\n %4d %d %d %d %d",i1,i2,i3,i1-i_count1+j1,i_count1);

r2=1.;
r=0.;
for(i=0;i<j1;i++)
{
i3=buf[i1-i_count1+j1-i-1];
//printf("\n %4d %d",i,i3);
//getch();
if(i3==48){r1=0.;r=r+r1*tt[i];}
if(i3==49){r1=1.;r=r+r1*tt[i];}
if(i3==50){r1=2.;r=r+r1*tt[i];}
if(i3==51){r1=3.;r=r+r1*tt[i];}
if(i3==52){r1=4.;r=r+r1*tt[i];}
if(i3==53){r1=5.;r=r+r1*tt[i];}
if(i3==54){r1=6.;r=r+r1*tt[i];}
if(i3==55){r1=7.;r=r+r1*tt[i];}
if(i3==56){r1=8.;r=r+r1*tt[i];}
if(i3==57){r1=9.;r=r+r1*tt[i];}
if(i3==45){r2=-1.;}
}

for(i=0;i<i_count1-j1-2;i++)
{
i3=buf[i1-i_count1+j1+i+1];
if(i3==48){r1=0.;}
if(i3==49){r1=1.;}
if(i3==50){r1=2.;}
if(i3==51){r1=3.;}
if(i3==52){r1=4.;}
if(i3==53){r1=5.;}
if(i3==54){r1=6.;}
if(i3==55){r1=7.;}
if(i3==56){r1=8.;}
if(i3==57){r1=9.;}
r=r+r1*ttt[i];
}

s_eps[i2]=r2*r;
//printf("\n++ %4d %20.18f",i2,s_eps[i2]);
//getch();

i2=i2+1;
if(i2<i_string) {goto mn2;}		// NEW Sample

//getch();

//2.3___VERIFICATION OF THE PROCESSING DATA (CHECKING FOR THE DUBLICATES)_____
for(j=0;j<i_string-1;j++)
{
	for(i=j+1;i<i_string;i++)
	{
   i10=0;
		for(i1=0;i1<i_max*8;i1++)
		{
      if(s_smile[j][i1]!=s_smile[i][i1]) {i10=1;}
      }
if(i10==0)
{
s_eps[i]=s_eps[j];
}
   }//i
}//j
//______________________________

//3________________PREPARATION OF THE TEST POOL___________
ippp=1;
		for(i1=0;i1<i_string;i1++)
		{
      i_sm[i1]=-1;
      }

		for(i1=0;i1<(int)(0.05*i_string);i1++)
		{
      i_sm[i1]=10+15*i1;
      }

printf("\n Introduce type of SMILES representation, 1-binary | 2- decimal");
scanf("%d",&i_representation);
//printf("activation %d",i_representation);

if (i_representation == 1)
{
i_max = i_max *8;
goto iter_bin;
}
//3.1_********************* decimal SMILES representation****************************
for (i1=0 ; i1<i_string ; i1++)
{
  for (i=0 ; i<i_max ; i++)			//1136:8=142
  {
  r7=s_smile[i1][i*8];
  if(r7<0.){r7=0.;}
	  r6=s_smile[i1][i*8+1];
     if(r6<0.){r6=0.;}
		  r5=s_smile[i1][i*8+2];
	     if(r5<0.){r5=0.;}
			  r4=s_smile[i1][i*8+3];
		     if(r4<0.){r4=0.;}
				  r3=s_smile[i1][i*8+4];
			     if(r3<0.){r3=0.;}
					  r2=s_smile[i1][i*8+5];
				     if(r2<0.){r2=0.;}
						  r1=s_smile[i1][i*8+6];
					     if(r1<0.){r1=0.;}
							  r=s_smile[i1][i*8+7];
						     if(r<0.){r=0.;}
  r=r7*128.+r6*64.+r5*32.+r4*16.+r3*8.+r2*4.+r1*2.+r;
  s_smile[i1][i]=r-32.;
  }
}//i1

iter_bin:
//4_________________________ LEARNING BP PROSEDURE___________________________
//4.1 ___________________ INITIALIZATION _________________________
//
//First Layer
l1=i_max;
l2=i_max;
l3=1;
l4=1;
for(j=0;j<l1;j++)
{
  for (i=0 ; i<l1 ; i++)
  {
  w1[j][i]=2./sqrt(i_max+1.)*(0.5-(double)(rand()/32768.));

  }
}

//Output Layer
for(j=0;j<l3;j++)
{
  for (i=0 ; i<l1 ; i++)
  {
  w3[j][i]=2./sqrt(i_max+1.)*(0.5-(double)(rand()/32768.));

  }
}

//Context Unit Layer
for(j=0;j<l1;j++)
{
  for (i=0 ; i<l1 ; i++)
  {
  w1p[j][i]=2./sqrt(i_max+1.)*(0.5-(double)(rand()/32768.));

  }
}
  for (i=0 ; i<l1 ; i++)	//RECURRENT
  {
  x1[i]=0.;
  }

  for (i=0 ; i<l4 ; i++)	//RECURRENT
  {
  x3[i]=0.;
  }

// _________________ END FOR INITIALIZATION ____________________


j2=0;
do		//__________________________________________________________
{
ipp=ipp+1;
p=p+1;
jsum=jsum+1;

// 4.2_********************* BACKPROPAGATION ************************

//  The generating training seguence

iter3:
j=rand()%i_string;		//RANDOM NUMBER FOR LEARNING TRAINS
jjj=j;

  d[0]=s_eps[j]; /*Original eps data*/
//___Selection of the learning pool_______
ill=0;
for(i=0;i<i_string/ippp;i++)
{
if(j==i_sm[i]) {ill=1;}
}
if(ill==1){goto iter3;}

// INPUT
  for (i=0 ; i<l1 ; i++)			//Normalization
  {
  x[i]=s_smile[j][i]*ap;
  }


// ********  The calculation of s[] ***********
//for the first layer
for(j=0;j<l1;j++)
{
  s1[j]=0.;
    for(i=0;i<l1;i++)
    {
    s1[j]=s1[j]+w1[j][i]*x[i];
    }
	    for(i=0;i<l1;i++)	//RECURRENT
   	 {
	    s1[j]=s1[j]+w1p[j][i]*x1[i];
   	 }

if (i_activation == 2)
{
//Sigmoid
r=s1[j];
if(r>15.){r=15.;}
if(r<-15.){r=-15.;}
    x11[j]=1./(1.+exp(-r));
}
if (i_activation == 1)
{
//tanh
r=s1[j];
x11[j]=tanh(r);
}
if (i_activation == 3)
{
//RELU
if(s1[j]<0.){x11[j]=0.;}
if(s1[j]>0.){x11[j]=s1[j];}
}
}//j

for(j=0;j<l1;j++)
{
//x1[j]=x11[j];
}

//for the output layer
for(j=0;j<l3;j++)
{
  s3[j]=0.;
    for(i=0;i<l1;i++)
    {
    s3[j]=s3[j]+w3[j][i]*x11[i];
    }
    x3[j]=s3[j];// output
}
//__________RMSE calculation________
eps=0.;
for(i=0;i<l3;i++)
{
eps=eps+(d[i]-x3[i])*(d[i]-x3[i]);
}

// The del3 calculation
for(i=0;i<l3;i++)
{
del3[i]=(d[0]-x3[i]);
}
// The del1 calculation for Wp
for(i=0;i<l1;i++)
{
er[i]=0.;
  for(j=0;j<l3;j++)
  {
  er[i]=er[i]+del3[j]*w3[j][i];
  }
}
    for(i=0;i<l1;i++)
    {
if (i_activation == 2)
{
//Sigmoid
    del1[i]=er[i]*x11[i]*(1.-x11[i]);
}
if (i_activation == 1)
{
//tanh
    del1[i]=er[i]*(1.-x11[i]*x11[i]);
}
if (i_activation == 3)
{
//RELU
    if(s1[i]<0.){r=0.;}
    if(s1[i]>0.){r=1.;}
    del1[i]=er[i]*r;
}
	 }

//RECURRENT
for(j=0;j<l2;j++)
{
  for (i=0 ; i<l1 ; i++)
  {
   w1p[j][i]=w1p[j][i]+alf*del1[j]*x1[i];
  }
}


for(j=0;j<l1;j++)
{
x1[j]=x11[j];
}


// The del1 calculation for Wx
for(i=0;i<l1;i++)
{
er[i]=0.;
  for(j=0;j<l3;j++)
  {
  er[i]=er[i]+del3[j]*w3[j][i];
  }
}
    for(i=0;i<l1;i++)
    {
if (i_activation == 2)
{
//Sigmoid
    del1[i]=er[i]*x11[i]*(1.-x11[i]);
}
if (i_activation == 1)
{
//tanh
    del1[i]=er[i]*(1.-x11[i]*x11[i]);
}
if (i_activation == 3)
{
//RELU
    if(s1[i]<0.){r=0.;}
    if(s1[i]>0.){r=1.;}
    del1[i]=er[i]*r;
}
    }

//1
for(j=0;j<l1;j++)
{
  for (i=0 ; i<l1 ; i++)
  {
   w1[j][i]=w1[j][i]+alf*del1[j]*x[i];
  }
}

//output
for(j=0;j<l3;j++)
{
  for (i=0 ; i<l2 ; i++)
  {
   w3[j][i]=w3[j][i]+alf*del3[j]*x1[i];
  }
}

//4.3_______________________ Batch-dependent RMSE calculation _____________________________

if((ipp%(i_string)==0))
{
i_count2=i_count2+1;


  for (i=0 ; i<l1; i++)
  {
  x4[i]=x1[i];
  }


printf("\n");
i_count=0;
i_count3=0;
sum=0.;
sum3=0.;


for(jj=0;jj<i_string;jj++)
{

  d[0]=s_eps[jj];

jjj=0;
iter5:

// INPUT
  for (i=0 ; i<l1; i++)
  {
  x[i]=s_smile[jj][i]*ap;
  }

//for the first layer
for(j=0;j<l1;j++)
{
  s1[j]=0.;
    for(i=0;i<l1;i++)
    {
    s1[j]=s1[j]+w1[j][i]*x[i];
    }

	   for(i=0;i<l1;i++)
   	{
    	s1[j]=s1[j]+w1p[j][i]*x4[i];
      }
if (i_activation == 2)
{
//Sigmoid
r=s1[j];
if(r>15.){r=15.;}
if(r<-15.){r=-15.;}
x11[j]=1./(1.+exp(-r));
}
if (i_activation == 1)
{
//tanh
r=s1[j];
x11[j]=tanh(r);
}
if (i_activation == 3)
{
//RELU
if(s1[j]<0.){x11[j]=0.;}
if(s1[j]>0.){x11[j]=s1[j];}
}
}

for(j=0;j<l1;j++)
{
//x4[j]=x11[j];
}


//for the output layer
for(j=0;j<l3;j++)
{
  s3[j]=0.;
    for(i=0;i<l1;i++)
    {
    s3[j]=s3[j]+w3[j][i]*x11[i];
    }
    x3[j]=(s3[j]);// output
}


	ill=0;
	for(i=0;i<i_string/ippp;i++)
	{
	if(jj==i_sm[i]) {ill=1;}
	}

if(ill==1){stat[i_count]=x3[0];sum=sum+x3[0];i_count=i_count+1;}  /*For the test pool*/
if(ill==0){stat3[i_count3]=x3[0];sum3=sum3+x3[0];i_count3=i_count3+1;} /*For the learning pool*/
//iter31:

}//jj

printf("\n___ i_count= %d %d",i_count,i_count3);

sum=sum/i_count;
sum3=sum3/i_count3;

//4.3.1__________ RMSE calculation for the test and learning pools_____________

sigma=0.;
sigma3=0.;
i_count11=0;
i_count33=0;
for(i=0;i<i_string;i++)
{

	ill=0;
	for(i1=0;i1<i_string/ippp;i1++)
	{
	if(i==i_sm[i1]) {ill=1;}
	}

if(ill==1) {sigma=sigma+(stat[i_count11]-(s_eps[i]))*(stat[i_count11]-(s_eps[i]));i_count11=i_count11+1;} /*RMSE for the test pool*/
if(ill==0) {sigma3=sigma3+(stat3[i_count33]-(s_eps[i]))*(stat3[i_count33]-(s_eps[i]));i_count33=i_count33+1;} /*RMSE for the learning pool*/

//iter10:
}

sigma=sigma/i_count;
sigma3=sigma3/i_count3;
printf("\n average= %f sigma= %f",sum, sqrt(sigma));
printf("\n average= %f sigma3= %f",sum3, sqrt(sigma3));

r=sqrt(sigma);
if(min>r) {min=r;imin=ipp;}
r=sqrt(sigma3);
if(min3>r) {min3=r;imin=ipp;}
printf("\n %d imin= %d min= %f min3= %f",i_count2,imin,min,min3);

r=sqrt(sigma);
fprintf(stream1, "\n %f",r);

r=sqrt(sigma3);
fprintf(stream2, "\n %f",r);


}//if

   ip=ip+1;
}while(i_count2!=500);

//***************** END OF THE LEARNING PROCEDURE (500 EPOCHS) ***************************
//4.3.2___________Resulted implementation of RRN_______
{
  for (i=0 ; i<l1; i++)
  {
  x4[i]=x1[i];
  }
for(jj=0;jj<i_string;jj++)
{

  d[0]=s_eps[jj];

// INPUT
  for (i=0 ; i<l1; i++)
  {
  x[i]=s_smile[jj][i]*ap;
  }

//for the first layer
for(j=0;j<l1;j++)
{
  s1[j]=0.;
    for(i=0;i<l1;i++)
    {
    s1[j]=s1[j]+w1[j][i]*x[i];
    }
	   for(i=0;i<l1;i++)
   	{
    	s1[j]=s1[j]+w1p[j][i]*x4[i];
      }

if (i_activation == 2)
{
//Sigmoid
r=s1[j];
if(r>15.){r=15.;}
if(r<-15.){r=-15.;}
    x11[j]=1./(1.+exp(-r));
}
if (i_activation == 1)
{
//tanh
r=s1[j];
x11[j]=tanh(r);
}
if (i_activation == 3)
{
//RELU
if(s1[j]<0.){x11[j]=0.;}
if(s1[j]>0.){x11[j]=s1[j];}
}
}

for(j=0;j<l1;j++)
{
//x4[j]=x11[j];
//x4[j]=x11[j];
}


//for the output layer
for(j=0;j<l3;j++)
{
  s3[j]=0.;
    for(i=0;i<l1;i++)
    {
    s3[j]=s3[j]+w3[j][i]*x11[i];
    }
    x3[j]=(s3[j]);// output
    r=x3[j];
fprintf(stream3, "\n %f",r);
}

}//jj

}

fclose(stream3); /*resulted RMSE for the learning pool*/
fclose(stream1); /*resulted RMSE for the test pool*/
fclose(stream2); /*resulted eps prediction for the test and learning pools*/

getch();
getch();
return(0);


}


